package main

// Реализовать конкурентную запись данных в map.

import (
	"fmt"
	"sync"
	"time"
)

// RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать,
// но можно параллельно читать. Например, стандартный тип map.
// С помощью RWMutex обеспечивается параллельное чтение объекта несколькими
// горутинами, что улучшает производительность.

// Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock()
// в других горутинах будут ждать, пока вы не отпустите мьютекс через .Unlock().
// Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock()
// в другихгорутинах блокируются, вызовы .RLock() спокойно проходят. Когда отпускаете
// мьютекс через .RUnlock(), ждущие вызовы .Lock() по-очереди могут забирать мьютекс на себя.

type syncMap struct {
	mutex sync.RWMutex
	M   map[int]int
}

func main() {
	wg := sync.WaitGroup{}
	m := syncMap{M: make(map[int]int)}

	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(i int) {
			m.Add(i, i * 10)
			time.Sleep(100 * time.Millisecond)
			wg.Done()
		}(i)
	}
	wg.Wait()
	fmt.Println(m.M) // map[0:0 1:10 2:20 3:30 4:40 5:50 6:60 7:70 8:80 9:90]
}

func (m *syncMap) Add(key int, value int) {
	// при изменении данных блокирует и на запись, и на чтение
	// Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock()
	// в других горутинах будут ждать, пока вы не отпустите мьютекс через .Unlock().
	m.mutex.Lock()
	m.M[key] = value
	m.mutex.Unlock()
}

func (m *syncMap) Get(key int) int {
	// при чтении блокируем только на чтение 
	// не заблокируется если никто не пишет в мапу (если нет блокировки на запись)
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return m.M[key]
}
