package main

// Написать программу,
// которая конкурентно рассчитает значение квадратов чисел взятых из
// массива (2,4,6,8,10) и выведет их квадраты в stdout.

import (
	"fmt"
	"sync"
)

func main() {
	arr := []int{2, 4, 6, 8, 10}

	// Значения будут приходит в канал и записываться в map.
	// В канал они будут записываться не в порядке значений в массиве,
	// 		но читать их можно сразу после того, как горутина их вычислит
	// 		и отправит в канал.
	// С помощью мапы они выведутся в порядке массива, но после выполнения горутины.
	ch := make(chan int)
	m := make(map[int]int)
	
	// запускаем горутину, которая будет вычислять квадраты и отправлять их в канал
	go countSquares(arr, ch, m)

	// получаем значения из канала, пока его не закроют
	// выводим в main, т.к. он все равно должен ждать завершения countSquares
	for sq := range ch {
		fmt.Println(sq)
	}

	// выводим мапу
	// не нужен мьютекс, т.к. выводим не параллельно
	for _, elem := range arr {
		fmt.Println(m[elem])
	}
}

func countSquares(arr []int, ch chan<- int, m map[int]int) {
	// мьютекс для записи в мапу, т.к. она не потокобезопасна
	mx := sync.Mutex{}
	// создаем WaitGroup, чтобы ждать заврешения всех горутин, которые считают квадраты
	wg := sync.WaitGroup{}

	for _, number := range arr {
		// увеличиваем счетчик WaitGroup, т.к. запускаем еще одну горутину
		wg.Add(1)
		// Передаем number, т.к. цикл закончится быстро
		// (number вне анонимной горутины почти сразу станет равным последнему значению)
		go func(number int) {
			// после вычеслений нужно сказать что горутина выполнена
			defer wg.Done()
			sq := number * number
			ch <- sq

			mx.Lock()
			m[number] = sq
			mx.Unlock()

		}(number)
	}
	// ждем завершения всех горутин
	wg.Wait()
	// закрываем канал, чтобы сказать, что больше значений не будет
	close(ch)
}
